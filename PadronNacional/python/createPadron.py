import os
import re
from datetime import datetime

class PadronSQLGenerator:
    def __init__(self):
        self.table_name = "vitalis_padron_nacional"
        
    def validate_cedula(self, cedula):
        """Valida que la c√©dula tenga el formato correcto (9 d√≠gitos)"""
        if not cedula:
            return False
        # Verificar que tenga exactamente 9 d√≠gitos
        return len(cedula) == 9 and cedula.isdigit()
    
    def validate_codigo_electoral(self, codigo):
        """Valida que el c√≥digo electoral tenga el formato correcto (6 d√≠gitos)"""
        if not codigo:
            return False
        # Verificar que tenga exactamente 6 d√≠gitos
        return len(codigo) == 6 and codigo.isdigit()
        
    def generate_create_table_sql(self):
        """Genera el SQL para crear la tabla del padr√≥n nacional"""
        
        create_table_sql = f"""
-- Script generado autom√°ticamente para Padr√≥n Nacional Electoral de Costa Rica
-- Fecha de generaci√≥n: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-- Base de datos: Oracle 19c

-- Verificar si la tabla existe y eliminarla si es necesario
BEGIN
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE {self.table_name} CASCADE CONSTRAINTS';
        DBMS_OUTPUT.PUT_LINE('Tabla {self.table_name} eliminada exitosamente.');
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE != -942 THEN -- ORA-00942: table or view does not exist
                RAISE;
            ELSE
                DBMS_OUTPUT.PUT_LINE('La tabla {self.table_name} no exist√≠a previamente.');
            END IF;
    END;
END;
/

-- Crear la tabla del padr√≥n nacional
CREATE TABLE {self.table_name} (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cedula VARCHAR2(9) NOT NULL,
    codigo_electoral VARCHAR2(6) NOT NULL,
    fecha_caducidad DATE,
    junta_receptora VARCHAR2(5),
    nombre VARCHAR2(30),
    primer_apellido VARCHAR2(30),
    segundo_apellido VARCHAR2(30),
    provincia VARCHAR2(15),
    canton VARCHAR2(25),
    distrito VARCHAR2(40),
    fecha_insercion DATE DEFAULT SYSDATE,
    CONSTRAINT uk_{self.table_name}_cedula UNIQUE (cedula)
);

-- Crear √≠ndices para optimizar consultas
CREATE INDEX idx_{self.table_name}_cedula ON {self.table_name}(cedula);
CREATE INDEX idx_{self.table_name}_codigo_electoral ON {self.table_name}(codigo_electoral);
CREATE INDEX idx_{self.table_name}_nombre ON {self.table_name}(nombre);
CREATE INDEX idx_{self.table_name}_apellidos ON {self.table_name}(primer_apellido, segundo_apellido);
CREATE INDEX idx_{self.table_name}_ubicacion ON {self.table_name}(provincia, canton, distrito);

-- Agregar comentarios a la tabla y columnas
COMMENT ON TABLE {self.table_name} IS 'Padr√≥n Nacional Electoral de Costa Rica';
COMMENT ON COLUMN {self.table_name}.cedula IS 'N√∫mero de c√©dula del ciudadano (9 d√≠gitos)';
COMMENT ON COLUMN {self.table_name}.codigo_electoral IS 'C√≥digo electoral donde est√° inscrito (6 d√≠gitos)';
COMMENT ON COLUMN {self.table_name}.fecha_caducidad IS 'Fecha de vencimiento de la c√©dula';
COMMENT ON COLUMN {self.table_name}.junta_receptora IS 'N√∫mero de Junta Receptora de Votos';
COMMENT ON COLUMN {self.table_name}.nombre IS 'Nombre completo del ciudadano';
COMMENT ON COLUMN {self.table_name}.primer_apellido IS 'Primer apellido';
COMMENT ON COLUMN {self.table_name}.segundo_apellido IS 'Segundo apellido';
COMMENT ON COLUMN {self.table_name}.provincia IS 'Nombre de la provincia';
COMMENT ON COLUMN {self.table_name}.canton IS 'Nombre del cant√≥n';
COMMENT ON COLUMN {self.table_name}.distrito IS 'Nombre del distrito';

DBMS_OUTPUT.PUT_LINE('Tabla {self.table_name} creada exitosamente con todos los √≠ndices y comentarios.');
"""
        return create_table_sql
    
    def parse_padron_line(self, line):
        """Parsea una l√≠nea del padr√≥n seg√∫n la estructura definida en Leame.txt"""
        # El archivo tiene formato h√≠brido: campos separados por comas pero con ancho fijo
        if not line or len(line) < 50:  # Verificaci√≥n m√≠nima de longitud
            return None
            
        try:
            # Dividir por comas y procesar cada campo
            parts = line.split(',')
            
            if len(parts) < 7:  # Debe tener al menos 7 campos
                return None
            
            # CEDULA: primer campo
            cedula = parts[0].strip()
            
            # CODELEC: segundo campo
            codigo_electoral = parts[1].strip()
            
            # RELLENO: tercer campo - se omite (parts[2])
            
            # FECHACADUC: cuarto campo
            fecha_caduc = parts[3].strip()
            
            # JUNTA: quinto campo
            junta = parts[4].strip()
            
            # NOMBRE: sexto campo
            nombre = parts[5].strip()
            
            # 1.APELLIDO: s√©ptimo campo
            primer_apellido = parts[6].strip()
            
            # 2.APELLIDO: octavo campo (si existe)
            segundo_apellido = parts[7].strip() if len(parts) > 7 else ""
            
            # Validar que los datos cr√≠ticos sean v√°lidos
            if not self.validate_cedula(cedula):
                return None
                
            if not self.validate_codigo_electoral(codigo_electoral):
                return None
            
            # Convertir fecha de YYYYMMDD a formato Oracle
            fecha_oracle = None
            if fecha_caduc and len(fecha_caduc) == 8 and fecha_caduc.isdigit():
                try:
                    year = fecha_caduc[:4]
                    month = fecha_caduc[4:6]
                    day = fecha_caduc[6:8]
                    fecha_oracle = f"{year}-{month}-{day}"
                except:
                    fecha_oracle = None
            
            return {
                'cedula': cedula,
                'codigo_electoral': codigo_electoral,
                'fecha_caducidad': fecha_oracle,
                'junta_receptora': junta,
                'nombre': nombre,
                'primer_apellido': primer_apellido,
                'segundo_apellido': segundo_apellido
            }
            
        except Exception as e:
            print(f"Error parseando l√≠nea: {e}")
            return None
    
    def load_districts_mapping(self, districts_file_path):
        """Carga el mapeo de c√≥digos electorales a ubicaciones geogr√°ficas desde DISTELEC.TXT"""
        districts_map = {}
        
        if not os.path.exists(districts_file_path):
            print(f"Advertencia: No se encontr√≥ el archivo {districts_file_path}")
            return districts_map
            
        try:
            # Intentar diferentes codificaciones comunes para archivos del TSE
            encodings = ['latin-1', 'cp1252', 'iso-8859-1', 'utf-8']
            file_loaded = False
            
            for encoding in encodings:
                try:
                    with open(districts_file_path, 'r', encoding=encoding) as file:
                        print(f"‚úì Archivo de distritos cargado con codificaci√≥n: {encoding}")
                        for line_num, line in enumerate(file, 1):
                            line = line.strip()
                            if not line:
                                continue
                                
                            # Los campos vienen separados por comas seg√∫n Leame.txt
                            parts = line.split(',')
                            if len(parts) >= 4:
                                codigo = parts[0].strip()
                                provincia = parts[1].strip()
                                canton = parts[2].strip()
                                distrito = parts[3].strip()
                                
                                # Validar que el c√≥digo tenga 6 d√≠gitos
                                if len(codigo) == 6 and codigo.isdigit():
                                    districts_map[codigo] = {
                                        'provincia': provincia,
                                        'canton': canton,
                                        'distrito': distrito
                                    }
                        
                        print(f"‚úì Cargados {len(districts_map)} distritos electorales")
                        file_loaded = True
                        break
                        
                except UnicodeDecodeError:
                    continue
            
            if not file_loaded:
                print(f"Error: No se pudo cargar el archivo con ninguna codificaci√≥n probada")
                
        except Exception as e:
            print(f"Error al cargar archivo de distritos: {e}")
            
        return districts_map
    
    def generate_insert_sql(self, padron_file_path, districts_file_path=None, batch_size=500):
        """Genera SQL de inserci√≥n para los datos del padr√≥n"""
        
        # Cargar mapeo de distritos si est√° disponible
        districts_map = {}
        if districts_file_path:
            districts_map = self.load_districts_mapping(districts_file_path)
        
        if not os.path.exists(padron_file_path):
            raise FileNotFoundError(f"No se encontr√≥ el archivo del padr√≥n: {padron_file_path}")
        
        insert_sql = f"""
-- Insertar datos del padr√≥n nacional
-- Archivo fuente: {padron_file_path}
-- Fecha de procesamiento: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-- Total de registros a insertar: Se calcular√° durante el procesamiento

"""
        
        batch_values = []
        total_records = 0
        
        try:
            # Intentar diferentes codificaciones para el archivo del padr√≥n
            encodings = ['latin-1', 'cp1252', 'iso-8859-1', 'utf-8']
            file_loaded = False
            
            for encoding in encodings:
                try:
                    with open(padron_file_path, 'r', encoding=encoding) as file:
                        print(f"‚úì Archivo del padr√≥n cargado con codificaci√≥n: {encoding}")
                        
                        for line_num, line in enumerate(file, 1):
                            # Mostrar progreso cada 100,000 l√≠neas
                            if line_num % 100000 == 0:
                                print(f"  Procesando l√≠nea {line_num:,}...")
                            
                            parsed_data = self.parse_padron_line(line)
                            
                            if not parsed_data or not parsed_data['cedula']:
                                continue
                            
                            # Obtener informaci√≥n geogr√°fica si est√° disponible
                            provincia = 'NULL'
                            canton = 'NULL'
                            distrito = 'NULL'
                            
                            if parsed_data['codigo_electoral'] in districts_map:
                                geo_info = districts_map[parsed_data['codigo_electoral']]
                                # Sanitizar valores geogr√°ficos y manejar caracteres especiales
                                provincia_clean = geo_info['provincia'].replace("'", "''").replace('"', '""') if geo_info['provincia'] else ''
                                canton_clean = geo_info['canton'].replace("'", "''").replace('"', '""') if geo_info['canton'] else ''
                                distrito_clean = geo_info['distrito'].replace("'", "''").replace('"', '""') if geo_info['distrito'] else ''
                                
                                provincia = f"'{provincia_clean}'" if provincia_clean else 'NULL'
                                canton = f"'{canton_clean}'" if canton_clean else 'NULL'
                                distrito = f"'{distrito_clean}'" if distrito_clean else 'NULL'
                            
                            # Sanitizar valores para evitar problemas con caracteres especiales
                            nombre_clean = parsed_data['nombre'].replace("'", "''").replace('"', '""') if parsed_data['nombre'] else ''
                            primer_apellido_clean = parsed_data['primer_apellido'].replace("'", "''").replace('"', '""') if parsed_data['primer_apellido'] else ''
                            segundo_apellido_clean = parsed_data['segundo_apellido'].replace("'", "''").replace('"', '""') if parsed_data['segundo_apellido'] else ''
                            
                            # Preparar valores para inserci√≥n
                            fecha_val = f"TO_DATE('{parsed_data['fecha_caducidad']}', 'YYYY-MM-DD')" if parsed_data['fecha_caducidad'] else 'NULL'
                            junta_val = f"'{parsed_data['junta_receptora']}'" if parsed_data['junta_receptora'] else 'NULL'
                            
                            values = f"""('{parsed_data['cedula']}', '{parsed_data['codigo_electoral']}', {fecha_val}, {junta_val}, 
                     '{nombre_clean}', '{primer_apellido_clean}', '{segundo_apellido_clean}',
                     {provincia}, {canton}, {distrito})"""
                            
                            batch_values.append(values)
                            total_records += 1
                            
                            # Procesar en lotes para optimizar rendimiento
                            if len(batch_values) >= batch_size:
                                insert_sql += self._generate_batch_insert(batch_values)
                                batch_values = []
                        
                        # Procesar el √∫ltimo lote si queda algo
                        if batch_values:
                            insert_sql += self._generate_batch_insert(batch_values)
                        
                        print(f"‚úì Procesamiento completado. Total de registros v√°lidos: {total_records:,}")
                        file_loaded = True
                        break
                        
                except UnicodeDecodeError:
                    print(f"  Probando siguiente codificaci√≥n...")
                    continue
                except Exception as e:
                    print(f"  Error con codificaci√≥n {encoding}: {e}")
                    continue
            
            if not file_loaded:
                raise Exception("No se pudo cargar el archivo con ninguna codificaci√≥n probada")
                
        except Exception as e:
            raise Exception(f"Error al procesar archivo del padr√≥n: {e}")
        
        insert_sql += f"""

-- Proceso completado
-- Total de registros procesados: {total_records:,}

-- Estad√≠sticas finales
SELECT 
    COUNT(*) as total_registros,
    COUNT(DISTINCT provincia) as total_provincias,
    COUNT(DISTINCT canton) as total_cantones,
    COUNT(DISTINCT distrito) as total_distritos
FROM {self.table_name};
"""
        
        return insert_sql, total_records
    
    def _generate_batch_insert(self, batch_values):
        """Genera INSERT statements individuales para cada registro"""
        insert_statements = ""
        
        for i, values in enumerate(batch_values):
            insert_statements += f"""INSERT INTO {self.table_name} 
    (cedula, codigo_electoral, fecha_caducidad, junta_receptora, nombre, primer_apellido, segundo_apellido, provincia, canton, distrito)
VALUES {values};
"""
        
        return insert_statements
    
    def generate_complete_script(self, padron_file_path, districts_file_path=None, output_file=None):
        """Genera el script SQL completo"""
        
        print("Generando script SQL para el Padr√≥n Nacional de Costa Rica...")
        
        # Generar SQL de creaci√≥n de tabla
        create_sql = self.generate_create_table_sql()
        
        # Generar SQL de inserci√≥n de datos
        try:
            insert_sql, total_records = self.generate_insert_sql(padron_file_path, districts_file_path)
            print(f"Se procesar√°n {total_records:,} registros del padr√≥n")
        except Exception as e:
            print(f"Error al generar SQL de inserci√≥n: {e}")
            return None
        
        # Combinar scripts
        complete_sql = create_sql + "\n\n" + insert_sql
        
        # Guardar en archivo si se especifica
        if output_file:
            try:
                # Usar UTF-8 con BOM para compatibilidad con herramientas SQL
                with open(output_file, 'w', encoding='utf-8-sig') as f:
                    f.write(complete_sql)
                print(f"‚úì Script SQL guardado en: {output_file}")
                print(f"  Codificaci√≥n: UTF-8 con BOM (compatible con Oracle SQL Developer)")
                
                # Mostrar informaci√≥n del archivo generado
                import os
                file_size = os.path.getsize(output_file)
                size_mb = file_size / (1024 * 1024)
                print(f"  Tama√±o del archivo: {size_mb:.2f} MB")
                
            except Exception as e:
                print(f"Error al guardar archivo: {e}")
                return None
        
        return complete_sql

# Ejemplo de uso
if __name__ == "__main__":
    generator = PadronSQLGenerator()
    
    # Configurar rutas de archivos
    padron_file = "PADRON_COMPLETO.txt"  # Archivo del padr√≥n completo
    districts_file = "Distelec.txt"      # Archivo de distritos electorales
    output_file = "vitalis_padron_nacional_oracle.sql"
    
    print("="*70)
    print("GENERADOR SQL PARA PADR√ìN NACIONAL DE COSTA RICA")
    print("Base de datos: Oracle 19c")
    print("Tabla destino: vitalis_padron_nacional")
    print("="*70)
    
    # Verificar que el archivo del padr√≥n existe
    if not os.path.exists(padron_file):
        print(f"‚ùå Error: No se encontr√≥ el archivo {padron_file}")
        print("Por favor, aseg√∫rate de que el archivo del padr√≥n est√© en la misma carpeta que este script.")
        print("\nArchivos esperados:")
        print("- PADRON_COMPLETO.txt (archivo principal del padr√≥n)")
        print("- Distelec.txt (archivo de distritos electorales - opcional)")
    else:
        print(f"‚úì Archivo del padr√≥n encontrado: {padron_file}")
        
        # Verificar archivo de distritos
        if os.path.exists(districts_file):
            print(f"‚úì Archivo de distritos encontrado: {districts_file}")
        else:
            print(f"‚ö† Archivo de distritos no encontrado: {districts_file}")
            print("  Se continuar√° sin informaci√≥n geogr√°fica detallada")
            districts_file = None
        
        print("\nGenerando script SQL...")
        
        # Generar script SQL completo
        sql_script = generator.generate_complete_script(
            padron_file_path=padron_file,
            districts_file_path=districts_file,
            output_file=output_file
        )
        
        if sql_script:
            print("\n" + "="*70)
            print("‚úÖ SCRIPT SQL GENERADO EXITOSAMENTE")
            print("="*70)
            print(f"üìÅ Archivo de salida: {output_file}")
            print(f"üìä Tabla destino: vitalis_padron_nacional")
            print("\nüìã INSTRUCCIONES PARA EJECUTAR:")
            print("1. Conectarse a Oracle 19c con privilegios de DDL/DML")
            print("2. Ejecutar el script SQL generado (puede tomar varios minutos)")
            print("3. Verificar que los datos se insertaron correctamente")
            print("4. Revisar las estad√≠sticas finales al completar")
            print("\nüìù CARACTER√çSTICAS DEL SCRIPT:")
            print("- ‚úì Manejo autom√°tico de IF EXISTS (DROP/CREATE)")
            print("- ‚úì INSERT statements individuales (sin PL/SQL)")
            print("- ‚úì Datos completamente generados por Python")
            print("- ‚úì √çndices optimizados para consultas")
            print("- ‚úì Comentarios descriptivos en tabla y columnas")
            print("- ‚úì Estad√≠sticas finales de consulta")
            print("- ‚úì Validaci√≥n de formato de c√©dulas y c√≥digos electorales")
            print("- ‚úì Sanitizaci√≥n de caracteres especiales")
            print("- ‚úì Archivo SQL ejecutable directamente en Oracle")
            
            if districts_file:
                print("- ‚úì Informaci√≥n geogr√°fica incluida (provincia, cant√≥n, distrito)")
            else:
                print("- ‚ö† Sin informaci√≥n geogr√°fica (solo c√≥digo electoral)")
                
        else:
            print("\n‚ùå ERROR: No se pudo generar el script SQL")
            print("Revisa los mensajes de error anteriores para m√°s detalles")